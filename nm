成功版本1：
mydefs：

// #pragma once
// /* Put other #includes here,
//    your struct board, helper function
//    prototypes etc.
// */
// /* 将其他 #include 放在这里，
// mydefs.h
#pragma once
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
/* === 棋盘尺寸 === */
#define H 4
#define W 5
/* === 棋盘结构：0 为空，1..9 为数字 === */
typedef struct {
    unsigned char a[H][W];
} board;
/* === 可选：单元格坐标类型（组织结构） === */
typedef struct {
    int r;
    int c;
} cell;
/* === BFS 用 ToDo（待办）数组/队列 === */
#ifndef MAXLIST
#define MAXLIST 100000
#endif
typedef struct {
    board items[MAXLIST];  /* 保存搜索到的盘面 */
    int   head;            /* 队首索引（取出） */
    int   tail;            /* 队尾索引（写入的下一个位置） */
} todo_array;
/* === 可选：搜索属性（如果需要 has 等开关，放这里） === */
typedef struct {
    bool has_seen_dedup;   /* 是否启用去重；示例属性 */
} search_attrs;
/* === 仅声明：辅助函数原型（实现写在 nm.c 中） === */
/* 边界判断 */
bool inb(int r, int c);
/* 8 邻接判断（dr,dc 是否为 8 邻接位移） */
bool is_adj8(int dr, int dc);
/* 方向归一化工具（把整数收敛到 -1/0/1） */
void norm1(int *x);
void norm_dir(int *dr, int *dc);
/* 两数是否匹配：相同或和为 10 */
bool values_match(unsigned char x, unsigned char y);
/* 是否在 8 个方向之一的直线上，返回单位方向 */
bool same_line_8(int r1, int c1, int r2, int c2, int *odr, int *odc);
/* 直线连通性：r1c1 到 r2c2 在同向直线且中间全为空 */
bool path_clear(const board *b, int r1, int c1, int r2, int c2);
/* 终局判断：是否全 0 */
bool is_final_board(const board *b);
/* 去重：arr[0..n) 中是否已包含 x */
bool seen_board(const board *arr, int n, const board *x);

Nm.c

// #include "nm.h"
// bool solve(int seed)
// {
// }
// bool take(board* p, pair z)
// {
// }
// board randfill(int n)
// {
// }
// void test(void)
// {
// }
// nm.c
// nm.c
// nm.c
// nm.c  —— 纯C(C99)实现
// nm.c — Linux 版（C99），与题目 nm.h / mydefs.h 配套

// nm.c —— Linux/gcc (C99) 版实现
#include "nm.h"       // 里面已包含 mydefs.h（board/常量/原型）
#include <string.h>   // memcmp
#include <stdlib.h>   // srand, rand
#include <assert.h>   // assert
/* ========= 辅助函数实现（与 mydefs.h 的原型一致，非 static） ========= */
bool inb(int r, int c){
    return r >= 0 && r < H && c >= 0 && c < W;
}
bool is_adj8(int dr, int dc){
    return (dr >= -1 && dr <= 1 && dc >= -1 && dc <= 1 && !(dr == 0 && dc == 0));
}
void norm1(int *x){
    if (*x > 0) *x = 1;
    else if (*x < 0) *x = -1;
}
void norm_dir(int *dr, int *dc){
    norm1(dr);
    norm1(dc);
}
bool values_match(unsigned char x, unsigned char y){
    return (x == y) || ((int)x + (int)y == 10);
}
bool same_line_8(int r1, int c1, int r2, int c2, int *odr, int *odc){
    int dr = r2 - r1, dc = c2 - c1;
    // 行/列/两条对角线之一
    if (!(dr == 0 || dc == 0 || (dr != 0 && dc != 0 && (dr == dc || dr == -dc))))
        return false;
    norm_dir(&dr, &dc);
    if (dr == 0 && dc == 0) return false;
    if (odr) *odr = dr;
    if (odc) *odc = dc;
    return true;
}
bool path_clear(const board *b, int r1, int c1, int r2, int c2){
    int dr, dc;
    if (!same_line_8(r1, c1, r2, c2, &dr, &dc)) return false;
    int r = r1 + dr, c = c1 + dc;
    while (!(r == r2 && c == c2)) {
        if (b->a[r][c] != 0) return false;
        r += dr; c += dc;
    }
    return true;
}
bool is_final_board(const board *b){
    for (int r = 0; r < H; ++r)
        for (int c = 0; c < W; ++c)
            if (b->a[r][c] != 0) return false;
    return true;
}
bool seen_board(const board *arr, int n, const board *x){
    for (int i = 0; i < n; ++i)
        if (memcmp(&arr[i], x, sizeof(board)) == 0) return true;
    return false;
}
/* ========= 题目要求的函数实现 =========
   nm.h 原型：
   board randfill(int n);
   bool  take(board* p, pair z);
   bool  solve(int seed);
   void  test(void);
*/
board randfill(int n){
    board b;
    srand(n);  // Linux/WSL2 与课程一致
    for (int r = 0; r < H; ++r)
        for (int c = 0; c < W; ++c)
            b.a[r][c] = (unsigned char)(rand() % 9 + 1); // 1..9
    return b;
}
/* 检查并“拿走”一对：
   条件：两格非 0，数值相同或和为 10，且 8 邻接 或 在同一直线且中间无其它数字。
   合法则置 0 并返回 true；否则不修改并返回 false。
*/
bool take(board *p, pair z){
    int r1 = z.x1, c1 = z.y1, r2 = z.x2, c2 = z.y2;
    if (!inb(r1, c1) || !inb(r2, c2)) return false;
    if (r1 == r2 && c1 == c2) return false;
    unsigned char v1 = p->a[r1][c1], v2 = p->a[r2][c2];
    if (v1 == 0 || v2 == 0) return false;
    if (!values_match(v1, v2)) return false;
    int dr = r2 - r1, dc = c2 - c1;
    bool ok = is_adj8(dr, dc) ? true : path_clear(p, r1, c1, r2, c2);
    if (!ok) return false;
    p->a[r1][c1] = 0;
    p->a[r2][c2] = 0;
    return true;
}
/* 广度优先搜索（BFS，固定数组，不用动态结构/链表）：
   - 起点是 randfill(seed)
   - 对每个非零格，沿 8 个方向找到“第一个非零格”，若可配对则生成子局面
   - 线性去重
   - 找到全空即返回 true，否则队列耗尽返回 false
*/
bool solve(int seed){
    todo_array Q;                 // 使用 mydefs.h 中的 ToDo 组织
    Q.head = 0; Q.tail = 0;
    Q.items[Q.tail++] = randfill(seed);
    static const int dirs[8][2] = {
        {-1,-1},{-1,0},{-1,1},
        { 0,-1},       { 0,1},
        { 1,-1},{ 1,0},{ 1,1}
    };
    while (Q.head < Q.tail) {
        board cur = Q.items[Q.head++];
        if (is_final_board(&cur)) return true;
        for (int r1 = 0; r1 < H; ++r1) {
            for (int c1 = 0; c1 < W; ++c1) {
                if (cur.a[r1][c1] == 0) continue;
                for (int d = 0; d < 8; ++d) {
                    int dr = dirs[d][0], dc = dirs[d][1];
                    int r = r1 + dr, c = c1 + dc;
                    // 沿该方向跳过 0，停在第一个非零
                    while (inb(r, c) && cur.a[r][c] == 0) { r += dr; c += dc; }
                    if (!inb(r, c)) continue; // 越界
                    board nxt = cur;
                    pair z = (pair){ r1, c1, r, c };
                    if (!take(&nxt, z)) continue;
                    if (!seen_board(Q.items, Q.tail, &nxt)) {
                        if (Q.tail >= MAXLIST) return false; // 容量耗尽，按题意失败
                        Q.items[Q.tail++] = nxt;
                        if (is_final_board(&nxt)) return true;
                    }
                }
            }
        }
    }
    return false;
}
/* 可选自测（不影响 driver） */
void test(void){
    // 邻接且相等
    {
        board b = {0};
        b.a[0][0] = 4; b.a[0][1] = 4;
        board t = b;
        assert(take(&t, (pair){0,0,0,1}) == true);
        assert(t.a[0][0] == 0 && t.a[0][1] == 0);
    }
    // 同列、和为 10、路径空
    {
        board b = {0};
        b.a[0][2] = 6; b.a[3][2] = 4;
        board t = b;
        assert(take(&t, (pair){0,2,3,2}) == true);
    }
    // 中间被阻挡 -> 失败
    {
        board b = {0};
        b.a[0][0] = 5; b.a[0][2] = 5; b.a[0][1] = 9;
        board t = b;
        assert(take(&t, (pair){0,0,0,2}) == false);
    }
}


成功版本2：
cd "/Users/gigi/Desktop/C/numMatch/"
gcc -std=c99 -Wall -Wextra nm.c driver.c -o nm
./nm

Mydefs

// #pragma once
// /* Put other #includes here,
//    your struct board, helper function
//    prototypes etc.
// */
// /* 将其他 #include 放在这里，
// mydefs.h
#pragma once
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
/* === 棋盘尺寸（按题意固定） === */
#define H 4
#define W 5
/* === 棋盘：0 表示空；1..9 为数字 === */
typedef struct {
    unsigned char a[H][W];
} board;
/* === 可选：单元格坐标类型（组织结构用） === */
typedef struct {
    int r;
    int c;
} cell;
/* === BFS 用 ToDo（待办）数组/队列（固定容量，禁止动态内存） === */
#ifndef MAXLIST
#define MAXLIST 100000
#endif
typedef struct {
    board items[MAXLIST];  /* 待处理的盘面队列 */
    int   head;            /* 队首（出队位置） */
    int   tail;            /* 队尾（下一次入队位置） */
} todo_array;
/* === 可选：搜索属性/开关（如 has 属性，放这里） === */
typedef struct {
    bool has_seen_dedup;   /* 示例：是否启用去重检查 */
} search_attrs;
/* === 仅声明辅助函数原型（实现写在 nm.c；不写函数体） === */
/* 边界判断：坐标是否在 4×5 棋盘内 */
bool inb(int r, int c);
/* 8 邻接：位移 (dr,dc) 是否是 8 邻接（上下左右+对角；非 (0,0)） */
bool is_adj8(int dr, int dc);
/* 方向归一化工具：把整数压到 -1/0/1 */
void norm1(int *x);
void norm_dir(int *dr, int *dc);
/* 数值匹配：相同或和为 10 */
bool values_match(unsigned char x, unsigned char y);
/* 是否在 8 个方向之一的直线上；若是，返回单位方向 odr/odc ∈ {-1,0,1} */
bool same_line_8(int r1, int c1, int r2, int c2, int *odr, int *odc);
/* 直线连通：r1c1 到 r2c2 在同一条直线且中间全为 0 */
bool path_clear(const board *b, int r1, int c1, int r2, int c2);
/* 终局判断：棋盘是否全 0 */
bool is_final_board(const board *b);
/* 去重：arr[0..n) 是否已包含盘面 x */
bool seen_board(const board *arr, int n, const board *x);


Nm.c

// #include "nm.h"
// bool solve(int seed)
// {
// }
// bool take(board* p, pair z)
// {
// }
// board randfill(int n)
// {
// }
// void test(void)
// {
// }
// nm.c
// nm.c
// nm.c
// nm.c  —— 纯C(C99)实现
// nm.c — Linux 版（C99），与题目 nm.h / mydefs.h 配套

// nm.c —— Linux/gcc (C99) 版实现
// nm.c —— Linux/gcc (C99) 实现：固定数组 + BFS；成功不输出
#include "nm.h"       // 其中已包含 mydefs.h 和 pair 的声明
#include <string.h>   // memcmp
#include <stdlib.h>   // srand, rand
#include <assert.h>   // assert
/* ========= 辅助函数实现（与 mydefs.h 的原型一致；非 static，便于测试） ========= */
bool inb(int r, int c){
    return r >= 0 && r < H && c >= 0 && c < W;
}
bool is_adj8(int dr, int dc){
    return (dr >= -1 && dr <= 1 && dc >= -1 && dc <= 1 && !(dr == 0 && dc == 0));
}
void norm1(int *x){
    if (*x > 0) *x = 1;
    else if (*x < 0) *x = -1;
}
void norm_dir(int *dr, int *dc){
    norm1(dr);
    norm1(dc);
}
bool values_match(unsigned char x, unsigned char y){
    return (x == y) || ((int)x + (int)y == 10);
}
bool same_line_8(int r1, int c1, int r2, int c2, int *odr, int *odc){
    int dr = r2 - r1, dc = c2 - c1;
    // 同一行/同一列/两条对角线之一
    if (!(dr == 0 || dc == 0 || (dr != 0 && dc != 0 && (dr == dc || dr == -dc))))
        return false;
    norm_dir(&dr, &dc);
    if (dr == 0 && dc == 0) return false;   // 同点
    if (odr) *odr = dr;
    if (odc) *odc = dc;
    return true;
}
bool path_clear(const board *b, int r1, int c1, int r2, int c2){
    int dr, dc;
    if (!same_line_8(r1, c1, r2, c2, &dr, &dc)) return false;
    int r = r1 + dr, c = c1 + dc;
    while (!(r == r2 && c == c2)) {
        if (b->a[r][c] != 0) return false;  // 中间必须全 0
        r += dr; c += dc;
    }
    return true;
}
bool is_final_board(const board *b){
    for (int r = 0; r < H; ++r)
        for (int c = 0; c < W; ++c)
            if (b->a[r][c] != 0) return false;
    return true;
}
bool seen_board(const board *arr, int n, const board *x){
    for (int i = 0; i < n; ++i)
        if (memcmp(&arr[i], x, sizeof(board)) == 0) return true;
    return false;
}
/* ========= 题目要求的函数实现 =========
   来自 nm.h：
   board randfill(int n);
   bool  take(board* p, pair z);
   bool  solve(int seed);
   void  test(void);
*/
board randfill(int seed){
    board b;
    srand(seed);  // 按课程环境（Linux/WSL2）的一致性
    for (int r = 0; r < H; ++r)
        for (int c = 0; c < W; ++c)
            b.a[r][c] = (unsigned char)(rand() % 9 + 1); // 1..9
    return b;
}
/* 尝试“拿走”一对格子：
   条件：坐标有效 & 两格非 0 & 数值相同或和为 10，
         且 (8 邻接) 或 (同一直线且中间全 0)。
   成功：把两格置 0，返回 true；否则不改动返回 false。
*/
bool take(board *p, pair z){
    int r1 = z.x1, c1 = z.y1, r2 = z.x2, c2 = z.y2;
    if (!inb(r1, c1) || !inb(r2, c2)) return false;
    if (r1 == r2 && c1 == c2) return false;
    unsigned char v1 = p->a[r1][c1], v2 = p->a[r2][c2];
    if (v1 == 0 || v2 == 0) return false;
    if (!values_match(v1, v2)) return false;
    int dr = r2 - r1, dc = c2 - c1;
    bool ok = is_adj8(dr, dc) ? true : path_clear(p, r1, c1, r2, c2);
    if (!ok) return false;
    p->a[r1][c1] = 0;
    p->a[r2][c2] = 0;
    return true;
}
/* 宽度优先搜索（BFS）：
   - 固定容量队列（todo_array），禁止动态内存/链表
   - 从 randfill(seed) 起始，逐层扩展所有“第一非零对”的可配对动作
   - 线性去重
   - 找到全 0 即 true；队列耗尽或容量用尽则 false
   - 成功时不向屏幕输出任何内容（静默）
*/
bool solve(int seed){
    todo_array Q;
    Q.head = 0;
    Q.tail = 0;
    Q.items[Q.tail++] = randfill(seed);
    static const int dirs[8][2] = {
        {-1,-1},{-1,0},{-1,1},
        { 0,-1},       { 0,1},
        { 1,-1},{ 1,0},{ 1,1}
    };
    while (Q.head < Q.tail) {
        board cur = Q.items[Q.head++];
        if (is_final_board(&cur)) return true;
        for (int r1 = 0; r1 < H; ++r1) {
            for (int c1 = 0; c1 < W; ++c1) {
                if (cur.a[r1][c1] == 0) continue;
                for (int d = 0; d < 8; ++d) {
                    int dr = dirs[d][0], dc = dirs[d][1];
                    int r = r1 + dr, c = c1 + dc;
                    // 沿该方向前进到“第一个非零格”（中间可跨 0）
                    while (inb(r, c) && cur.a[r][c] == 0) { r += dr; c += dc; }
                    if (!inb(r, c)) continue;  // 出界则该方向没有候选
                    board nxt = cur;
                    pair z = (pair){ r1, c1, r, c };
                    if (!take(&nxt, z)) continue;
                    if (!seen_board(Q.items, Q.tail, &nxt)) {
                        if (Q.tail >= MAXLIST) return false;  // 固定容量保护
                        Q.items[Q.tail++] = nxt;
                        if (is_final_board(&nxt)) return true; // 早停
                    }
                }
            }
        }
    }
    return false;  // 队列耗尽，无解
}
/* ========= test(): 断言测试（含辅助函数） =========
   任一断言失败会触发 abort (EXIT_FAILURE)；正常情况下不输出任何内容。
*/
void test(void){
    /* inb() */
    assert(inb(0,0) && inb(H-1, W-1));
    assert(!inb(-1,0) && !inb(0,-1) && !inb(H,0) && !inb(0,W));
    /* is_adj8() */
    assert(is_adj8(1,0) && is_adj8(0,1) && is_adj8(-1,-1));
    assert(!is_adj8(0,0) && !is_adj8(2,0) && !is_adj8(0,2));
    /* norm1 / norm_dir */
    { int x=5; norm1(&x); assert(x==1); x=-3; norm1(&x); assert(x==-1); x=0; norm1(&x); assert(x==0); }
    { int dr=3,dc=-7; norm_dir(&dr,&dc); assert(dr==1 && dc==-1); }
    /* values_match() */
    assert(values_match(4,6));   // 和为10
    assert(values_match(5,5));   // 相同
    assert(!values_match(2,7));  // 既不等也不满10
    /* same_line_8() */
    { int dr,dc; assert(same_line_8(0,0,0,4,&dr,&dc) && dr==0 && dc==1); }   // 同行
    { int dr,dc; assert(same_line_8(0,0,3,0,&dr,&dc) && dr==1 && dc==0); }   // 同列
    { int dr,dc; assert(same_line_8(0,0,3,3,&dr,&dc) && dr==1 && dc==1); }   // 主对角
    { int dr,dc; assert(same_line_8(3,0,0,3,&dr,&dc) && dr==-1 && dc==1); }  // 反对角
    { int dr,dc; assert(!same_line_8(0,0,1,2,&dr,&dc)); }                    // 非直线
    /* path_clear() */
    {
        board b = {0};
        b.a[0][0]=5; b.a[0][3]=5;
        assert(path_clear(&b,0,0,0,3)==true);  // 中间全 0
        b.a[0][1]=9;                           // 设置阻挡
        assert(path_clear(&b,0,0,0,3)==false);
    }
    /* seen_board() */
    {
        board arr[2] = {0};
        board x = {0};
        arr[0].a[1][1] = 7;
        x.a[1][1]       = 7;
        assert(seen_board(arr,1,&x)==true);
        x.a[1][1]       = 8;
        assert(seen_board(arr,1,&x)==false);
    }
    /* take()：合法与非法 */
    {
        board b = {0};
        b.a[1][0]=4; b.a[2][0]=6;             // 同列，和为 10，且中间无阻挡
        board t=b;
        assert(take(&t, (pair){1,0,2,0})==true);
        assert(t.a[1][0]==0 && t.a[2][0]==0);
    }
    {
        board b = {0};
        b.a[1][1]=4; b.a[1][3]=6;             // 同行，和为10，但中间有阻挡
        b.a[1][2]=9;
        board t=b;
        assert(take(&t, (pair){1,1,1,3})==false);
    }
    {
        board b = {0};
        b.a[0][0]=5; b.a[1][1]=5;             // 对角相邻，相同
        board t=b;
        assert(take(&t, (pair){0,0,1,1})==true);
        assert(t.a[0][0]==0 && t.a[1][1]==0);
    }
    /* 注意：不对 solve(seed) 做固定种子断言，以免不同平台 rand() 差异引起假失败。
       老师的 driver 会单独测 solve()；这里主要覆盖辅助函数与 take() 的边界。*/
}


