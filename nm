gcc nm.c driver.c -Wall -Wextra -std=c99 -o nm
./nm
--
[hy25163@it106297 num]$ gcc nm.c driver.c -Wall -Wextra -std=c99 -o nm
mnm.c:353:6: warning: ‘test’ defined but not used [-Wunused-function]
 void test(void){
      ^~~~
nm.c:314:6: warning: ‘solve’ defined but not used [-Wunused-function]
 bool solve(int seed){
      ^~~~~
[hy25163@it106297 num]$ ./nm
nm: driver.c:13: main: Assertion `take(&b, (pair){1,0,2,0})' failed.
Aborted (core dumped)
---
————
#pragma once
#include <stdbool.h>

#define H 4
#define W 5

#ifndef MAXLIST
#define MAXLIST 100000
#endif

typedef struct {
    unsigned char a[H][W];
} board;

typedef struct {
    board items[MAXLIST];
    int head;
    int tail;
} todo_array;
————
#include "nm.h"
#include <string.h>
#include <stdlib.h>
#include <assert.h>

/* 辅助函数 */

bool inb(int r, int c)
{
    return r >= 0 && r < H && c >= 0 && c < W;
}

bool is_adj8(int dr, int dc)
{
    return (dr >= -1 && dr <= 1 &&
            dc >= -1 && dc <= 1 &&
            !(dr == 0 && dc == 0));
}

void norm1(int *x)
{
    if (*x > 0) *x = 1;
    else if (*x < 0) *x = -1;
}

void norm_dir(int *dr, int *dc)
{
    norm1(dr);
    norm1(dc);
}

bool values_match(unsigned char x, unsigned char y)
{
    return (x == y) || (x + y == 10);
}

/* r1,c1 和 r2,c2 是否在一条水平/垂直/对角线方向上，
   若是，则把单位方向写到 *odr,*odc 中 */
bool same_line_8(int r1, int c1, int r2, int c2, int *odr, int *odc)
{
    int dr = r2 - r1;
    int dc = c2 - c1;

    /* 同点直接不算 */
    if (dr == 0 && dc == 0)
        return false;

    /* 同行：dr == 0 且 dc != 0
       同列：dc == 0 且 dr != 0
       对角：dr == dc 或 dr == -dc */
    if (!((dr == 0 && dc != 0) ||
          (dc == 0 && dr != 0) ||
          dr == dc ||
          dr == -dc))
        return false;

    norm_dir(&dr, &dc);
    if (odr) *odr = dr;
    if (odc) *odc = dc;
    return true;
}

/* 检查 r1,c1 到 r2,c2 之间是不是在一条直线且中间全 0 */
bool path_clear(const board *b, int r1, int c1, int r2, int c2)
{
    int dr, dc;
    if (!same_line_8(r1, c1, r2, c2, &dr, &dc))
        return false;

    int r = r1 + dr;
    int c = c1 + dc;
    while (!(r == r2 && c == c2)) {
        if (b->a[r][c] != 0)
            return false;
        r += dr;
        c += dc;
    }
    return true;
}

bool is_final_board(const board *b)
{
    for (int r = 0; r < H; ++r)
        for (int c = 0; c < W; ++c)
            if (b->a[r][c] != 0)
                return false;
    return true;
}

bool seen_board(const board *arr, int n, const board *x)
{
    for (int i = 0; i < n; ++i)
        if (memcmp(&arr[i], x, sizeof(board)) == 0)
            return true;
    return false;
}

/* 题目要求的四个函数 */

/* n 用来播种 srand，然后按行优先填满棋盘 */
board randfill(int seed)
{
    board b;
    srand(seed);
    for (int r = 0; r < H; ++r) {
        for (int c = 0; c < W; ++c) {
            b.a[r][c] = (unsigned char)(rand() % 9 + 1); /* 1..9 */
        }
    }
    return b;
}

/* pair 约定：x = 列，y = 行 */
bool take(board *p, pair z)
{
    int c1 = z.x1, r1 = z.y1;
    int c2 = z.x2, r2 = z.y2;

    if (!inb(r1, c1) || !inb(r2, c2))
        return false;
    if (r1 == r2 && c1 == c2)
        return false;

    unsigned char v1 = p->a[r1][c1];
    unsigned char v2 = p->a[r2][c2];

    if (v1 == 0 || v2 == 0)
        return false;
    if (!values_match(v1, v2))
        return false;

    int dr = r2 - r1;
    int dc = c2 - c1;

    bool ok;
    if (is_adj8(dr, dc))
        ok = true;
    else
        ok = path_clear(p, r1, c1, r2, c2);

    if (!ok)
        return false;

    p->a[r1][c1] = 0;
    p->a[r2][c2] = 0;
    return true;
}

/* BFS 解是否可消完 */
bool solve(int seed)
{
    todo_array Q;
    Q.head = 0;
    Q.tail = 0;

    Q.items[Q.tail++] = randfill(seed);

    static const int dirs[8][2] = {
        {-1,-1},{-1,0},{-1,1},
        { 0,-1},       { 0,1},
        { 1,-1},{ 1,0},{ 1,1}
    };

    while (Q.head < Q.tail) {
        board cur = Q.items[Q.head++];

        if (is_final_board(&cur))
            return true;

        for (int r1 = 0; r1 < H; ++r1) {
            for (int c1 = 0; c1 < W; ++c1) {
                if (cur.a[r1][c1] == 0)
                    continue;

                for (int d = 0; d < 8; ++d) {
                    int dr = dirs[d][0];
                    int dc = dirs[d][1];
                    int r = r1 + dr;
                    int c = c1 + dc;

                    /* 在这个方向上跳过 0，找到第一个非零格 */
                    while (inb(r, c) && cur.a[r][c] == 0) {
                        r += dr;
                        c += dc;
                    }
                    if (!inb(r, c))
                        continue;

                    board nxt = cur;
                    /* pair 用 (x=列, y=行) */
                    pair z = (pair){ c1, r1, c, r };

                    if (!take(&nxt, z))
                        continue;
                    if (!seen_board(Q.items, Q.tail, &nxt)) {
                        if (Q.tail >= MAXLIST)
                            return false;
                        Q.items[Q.tail++] = nxt;
                        if (is_final_board(&nxt))
                            return true;
                    }
                }
            }
        }
    }
    return false;
}

/* 自测：不动 randfill/solve 的随机序列 */

void test(void)
{
    /* inb */
    assert(inb(0,0));
    assert(inb(H-1, W-1));
    assert(!inb(-1,0));
    assert(!inb(0,-1));
    assert(!inb(H,0));
    assert(!inb(0,W));

    /* is_adj8 */
    assert(is_adj8(1,0));
    assert(is_adj8(0,1));
    assert(is_adj8(-1,-1));
    assert(!is_adj8(0,0));
    assert(!is_adj8(2,0));
    assert(!is_adj8(0,2));

    /* norm1 / norm_dir */
    {
        int x = 5;
        norm1(&x);
        assert(x == 1);
        x = -3;
        norm1(&x);
        assert(x == -1);
        x = 0;
        norm1(&x);
        assert(x == 0);
    }
    {
        int dr = 3, dc = -7;
        norm_dir(&dr, &dc);
        assert(dr == 1 && dc == -1);
    }

    /* values_match */
    assert(values_match(4,6));
    assert(values_match(5,5));
    assert(!values_match(2,7));

    /* same_line_8 */
    {
        int dr, dc;
        assert(same_line_8(0,0,0,4,&dr,&dc) && dr == 0 && dc == 1);
    }
    {
        int dr, dc;
        assert(same_line_8(0,0,3,0,&dr,&dc) && dr == 1 && dc == 0);
    }
    {
        int dr, dc;
        assert(same_line_8(0,0,3,3,&dr,&dc) && dr == 1 && dc == 1);
    }
    {
        int dr, dc;
        assert(same_line_8(3,0,0,3,&dr,&dc) && dr == -1 && dc == 1);
    }
    {
        int dr, dc;
        assert(!same_line_8(0,0,1,2,&dr,&dc));
    }

    /* path_clear */
    {
        board b = {0};
        b.a[0][0] = 5;
        b.a[0][3] = 5;
        assert(path_clear(&b,0,0,0,3));
        b.a[0][1] = 9;
        assert(!path_clear(&b,0,0,0,3));
    }

    /* seen_board */
    {
        board arr[2] = {0};
        board x = {0};
        arr[0].a[1][1] = 7;
        x.a[1][1] = 7;
        assert(seen_board(arr,1,&x));
        x.a[1][1] = 8;
        assert(!seen_board(arr,1,&x));
    }

    /* take：这里注意 pair 的坐标顺序 (x=列, y=行) */
    {
        board b = (board){0};
        b.a[1][0] = 4;
        b.a[2][0] = 6;
        board t = b;
        assert(take(&t, (pair){0,1,0,2}));
        assert(t.a[1][0] == 0 && t.a[2][0] == 0);
    }
    {
        board b = (board){0};
        b.a[1][1] = 4;
        b.a[1][3] = 6;
        b.a[1][2] = 9;
        board t = b;
        assert(!take(&t, (pair){1,1,3,1}));
    }
    {
        board b = (board){0};
        b.a[0][0] = 5;
        b.a[1][1] = 5;
        board t = b;
        assert(take(&t, (pair){0,0,1,1}));
        assert(t.a[0][0] == 0 && t.a[1][1] == 0);
    }
}
————
