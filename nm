gcc nm.c driver.c -Wall -Wextra -std=c99 -o nm
./nm
--
[hy25163@it106297 num]$ gcc nm.c driver.c -Wall -Wextra -std=c99 -o nm
mnm.c:353:6: warning: ‘test’ defined but not used [-Wunused-function]
 void test(void){
      ^~~~
nm.c:314:6: warning: ‘solve’ defined but not used [-Wunused-function]
 bool solve(int seed){
      ^~~~~
[hy25163@it106297 num]$ ./nm
nm: driver.c:13: main: Assertion `take(&b, (pair){1,0,2,0})' failed.
Aborted (core dumped)
---

// #include "nm.h"
// bool solve(int seed)
// {
// }
// bool take(board* p, pair z)
// {
// }
// board randfill(int n)
// {
// }
// void test(void)
// {
// }
// nm.c
// nm.c
// nm.c
// nm.c  —— 纯C(C99)实现
// nm.c — Linux 版（C99），与题目 nm.h / mydefs.h 配套

// nm.c —— Linux/gcc (C99) 版实现
// nm.c —— Linux/gcc (C99) 实现：固定数组 + BFS；成功不输出
// nm.c —— Linux/gcc (C99) 实现：固定数组 + BFS；成功不输出
#include "nm.h"       // 其中已包含 mydefs.h 和 pair 的声明
#include <string.h>   // memcmp
#include <stdlib.h>   // srand, rand
#include <assert.h>   // assert

/* ========= 辅助函数 ========= */

bool inb(int r, int c){
    return r >= 0 && r < H && c >= 0 && c < W;
}

bool is_adj8(int dr, int dc){
    return (dr >= -1 && dr <= 1 &&
            dc >= -1 && dc <= 1 &&
            !(dr == 0 && dc == 0));
}

void norm1(int *x){
    if (*x > 0) *x = 1;
    else if (*x < 0) *x = -1;
}

void norm_dir(int *dr, int *dc){
    norm1(dr);
    norm1(dc);
}

bool values_match(unsigned char x, unsigned char y){
    return (x == y) || (x + y == 10);
}

bool same_line_8(int r1, int c1, int r2, int c2, int *odr, int *odc){
    int dr = r2 - r1, dc = c2 - c1;

    /* 同一行 / 同一列 / 任一对角线 */
    if (!(dr == 0 || dc == 0 || (dr != 0 && dc != 0 && (dr == dc || dr == -dc))))
        return false;

    norm_dir(&dr, &dc);
    if (dr == 0 && dc == 0) return false;   // 同点（不允许）

    if (odr) *odr = dr;
    if (odc) *odc = dc;
    return true;
}

bool path_clear(const board *b, int r1, int c1, int r2, int c2){
    int dr, dc;
    if (!same_line_8(r1, c1, r2, c2, &dr, &dc)) return false;

    int r = r1 + dr;
    int c = c1 + dc;
    while (!(r == r2 && c == c2)) {
        if (b->a[r][c] != 0) return false;  // 中间必须全 0
        r += dr;
        c += dc;
    }
    return true;
}

bool is_final_board(const board *b){
    for (int r = 0; r < H; ++r)
        for (int c = 0; c < W; ++c)
            if (b->a[r][c] != 0) return false;
    return true;
}

bool seen_board(const board *arr, int n, const board *x){
    for (int i = 0; i < n; ++i)
        if (memcmp(&arr[i], x, sizeof(board)) == 0) return true;
    return false;
}

/* ========= 题目要求的函数实现 ========= */

board randfill(int seed){
    board b;
    srand(seed);
    for (int r = 0; r < H; ++r) {
        for (int c = 0; c < W; ++c) {
            b.a[r][c] = (unsigned char)(rand() % 9 + 1); // 1..9
        }
    }
    return b;
}

/* 尝试“拿走”一对格子：
   条件：坐标有效 & 两格非 0 & 数值相同或和为 10，
         且 (8 邻接) 或 (同一直线且中间全 0)。
   成功：把两格置 0，返回 true；否则不改动返回 false。
   注意：pair 约定为 (x1,y1,x2,y2) = (列1,行1,列2,行2)
*/
bool take(board *p, pair z){
    int r1 = z.y1, c1 = z.x1;
    int r2 = z.y2, c2 = z.x2;

    if (!inb(r1, c1) || !inb(r2, c2)) return false;
    if (r1 == r2 && c1 == c2) return false;

    unsigned char v1 = p->a[r1][c1];
    unsigned char v2 = p->a[r2][c2];

    if (v1 == 0 || v2 == 0) return false;
    if (!values_match(v1, v2)) return false;

    int dr = r2 - r1, dc = c2 - c1;
    bool ok = is_adj8(dr, dc) ? true : path_clear(p, r1, c1, r2, c2);
    if (!ok) return false;

    p->a[r1][c1] = 0;
    p->a[r2][c2] = 0;
    return true;
}

/* 宽度优先搜索（BFS） */
bool solve(int seed){
    todo_array Q;
    Q.head = 0;
    Q.tail = 0;

    Q.items[Q.tail++] = randfill(seed);

    static const int dirs[8][2] = {
        {-1,-1},{-1,0},{-1,1},
        { 0,-1},       { 0,1},
        { 1,-1},{ 1,0},{ 1,1}
    };

    while (Q.head < Q.tail) {
        board cur = Q.items[Q.head++];

        if (is_final_board(&cur)) return true;

        for (int r1 = 0; r1 < H; ++r1) {
            for (int c1 = 0; c1 < W; ++c1) {
                if (cur.a[r1][c1] == 0) continue;

                for (int d = 0; d < 8; ++d) {
                    int dr = dirs[d][0], dc = dirs[d][1];
                    int r = r1 + dr, c = c1 + dc;

                    /* 沿该方向前进到第一个非零格，中间可以跨 0 */
                    while (inb(r, c) && cur.a[r][c] == 0) {
                        r += dr;
                        c += dc;
                    }
                    if (!inb(r, c)) continue;  // 出界则该方向无候选

                    board nxt = cur;
                    /* 这里 pair 的 x=列, y=行 */
                    pair z = (pair){ c1, r1, c, r };

                    if (!take(&nxt, z)) continue;
                    if (!seen_board(Q.items, Q.tail, &nxt)) {
                        if (Q.tail >= MAXLIST) return false;
                        Q.items[Q.tail++] = nxt;
                        if (is_final_board(&nxt)) return true;
                    }
                }
            }
        }
    }
    return false;
}

/* ========= test(): 自测 ========= */

void test(void){
    /* inb() */
    assert(inb(0,0) && inb(H-1, W-1));
    assert(!inb(-1,0) && !inb(0,-1) && !inb(H,0) && !inb(0,W));

    /* is_adj8() */
    assert(is_adj8(1,0) && is_adj8(0,1) && is_adj8(-1,-1));
    assert(!is_adj8(0,0) && !is_adj8(2,0) && !is_adj8(0,2));

    /* norm1 / norm_dir */
    {
        int x = 5;  norm1(&x); assert(x == 1);
        x = -3;     norm1(&x); assert(x == -1);
        x = 0;      norm1(&x); assert(x == 0);
    }
    {
        int dr = 3, dc = -7;
        norm_dir(&dr, &dc);
        assert(dr == 1 && dc == -1);
    }

    /* values_match() */
    assert(values_match(4,6));   // 和为10
    assert(values_match(5,5));   // 相同
    assert(!values_match(2,7));  // 既不等也不满10

    /* same_line_8() */
    {
        int dr, dc;
        assert(same_line_8(0,0,0,4,&dr,&dc) && dr == 0 && dc == 1);   // 同行
    }
    {
        int dr, dc;
        assert(same_line_8(0,0,3,0,&dr,&dc) && dr == 1 && dc == 0);   // 同列
    }
    {
        int dr, dc;
        assert(same_line_8(0,0,3,3,&dr,&dc) && dr == 1 && dc == 1);   // 主对角
    }
    {
        int dr, dc;
        assert(same_line_8(3,0,0,3,&dr,&dc) && dr == -1 && dc == 1);  // 反对角
    }
    {
        int dr, dc;
        assert(!same_line_8(0,0,1,2,&dr,&dc));                        // 非直线
    }

    /* path_clear() */
    {
        board b = {0};
        b.a[0][0] = 5; b.a[0][3] = 5;
        assert(path_clear(&b,0,0,0,3) == true);  // 中间全 0
        b.a[0][1] = 9;                           // 设置阻挡
        assert(path_clear(&b,0,0,0,3) == false);
    }

    /* seen_board() */
    {
        board arr[2] = {0};
        board x = {0};
        arr[0].a[1][1] = 7;
        x.a[1][1]       = 7;
        assert(seen_board(arr,1,&x) == true);
        x.a[1][1]       = 8;
        assert(seen_board(arr,1,&x) == false);
    }

    /* take()：合法与非法（pair 按 x=列,y=行） */
    {
        board b = {0};
        /* 同列：列0，行1和2，值 4 和 6，和为 10 */
        b.a[1][0] = 4;
        b.a[2][0] = 6;
        board t = b;
        assert(take(&t, (pair){0,1,0,2}) == true);
        assert(t.a[1][0] == 0 && t.a[2][0] == 0);
    }
    {
        board b = {0};
        /* 同行：行1，列1和3，中间 (2,1) 有阻挡 */
        b.a[1][1] = 4;
        b.a[1][3] = 6;
        b.a[1][2] = 9;
        board t = b;
        assert(take(&t, (pair){1,1,3,1}) == false);
    }
    {
        board b = {0};
        /* 对角相邻： (0,0) 和 (1,1) */
        b.a[0][0] = 5;
        b.a[1][1] = 5;
        board t = b;
        assert(take(&t, (pair){0,0,1,1}) == true);
        assert(t.a[0][0] == 0 && t.a[1][1] == 0);
    }

    /* 不对 solve(seed) 做固定种子断言，留给老师 driver.c 测试 */
}
